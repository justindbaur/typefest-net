using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TypeFest.Net.Analyzer.Shared
{
    internal abstract record PartialTypeSpec
    {
        public required HierarchyInfo TargetType { get; init; }
        public required HierarchyInfo SourceType { get; init; }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");
            writer.WriteLine("#nullable enable");
            writer.WriteLine();

            if (TargetType.Namespace is not "")
            {
                writer.WriteLine($"namespace {TargetType.Namespace}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            EmitCore(writer);

            if (TargetType.Namespace is not "")
            {
                writer.Indent--;
                writer.Write("}");
            }
        }

        public abstract bool HasChanges { get; }

        public abstract IEnumerable<string> GetMemberNames();

        protected abstract void EmitCore(IndentedTextWriter writer);

        private static bool TryCreate(
            ISymbol targetSymbol,
            AttributeData attributeData,
            AttributeSyntax attributeSyntax,
            bool inSourceGenerator,
            [NotNullWhen(true)] out INamedTypeSymbol? targetType,
            [NotNullWhen(true)] out INamedTypeSymbol? sourceType,
            [NotNullWhen(true)] out ImmutableHashSet<string>? members,
            out ImmutableArray<DiagnosticInfo>.Builder diagnostics)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new InvalidOperationException("Target type is not a named type symbol, I think this should be impossible.");
            }

            // TODO: Validate partial but only when using source gen

            if (attributeData.AttributeClass == null)
            {
                throw new InvalidOperationException("AttributeData is expected to have a attribute class at this point, how did this happen?");
            }

            if (attributeData.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedSourceSymbol)
            {
                throw new InvalidOperationException("Expected a single, named type argument for one of our attributes.");
            }

            if (attributeData.ConstructorArguments is not [var firstArg, var paramsArg])
            {
                throw new InvalidOperationException($"Expected two args but instead got {attributeData.ConstructorArguments.Length}.");
            }

            if (paramsArg.Kind != TypedConstantKind.Array)
            {
                throw new InvalidOperationException("Expected an array for the second argument.");
            }

            var diagnosticsBuilder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

            // We do allow a struct -> class and class -> struct
            if ((namedSourceSymbol.TypeKind == TypeKind.Enum && namedTargetSymbol.TypeKind != TypeKind.Enum)
                || (namedSourceSymbol.TypeKind != TypeKind.Enum && namedTargetSymbol.TypeKind == TypeKind.Enum))
            {
                var location = attributeData.GetLocation();
                diagnosticsBuilder.Add(DiagnosticInfo.Create(
                    Diagnostics.InvalidTypeKind,
                    location,
                    namedTargetSymbol.TypeKind, namedSourceSymbol.TypeKind
                ));
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = null;
                return false;
            }

            var memberBuilder = ImmutableHashSet.CreateBuilder<string>();

            ImmutableHashSet<string> sourceMembers;
            if (namedSourceSymbol.TypeKind == TypeKind.Enum)
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Select(fs => fs.Name)
                    .ToImmutableHashSet();
            }
            else
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Select(ps => ps.Name)
                    .ToImmutableHashSet();
            }

            var targetTypeMembers = namedTargetSymbol.GetMembers()
                .Select(m => m.Name)
                .ToImmutableHashSet();

            bool ValidateAndAddMember(TypedConstant typedConstant, SyntaxNode argument)
            {
                if (typedConstant.IsNull)
                {
                    var location = argument.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.NullArgument,
                        location,
                        "null"
                    ));
                    return true;
                }

                var member = (string)typedConstant.Value!;

                if (!memberBuilder.Add(member))
                {
                    var location = argument.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.DuplicateArgument,
                        location,
                        member
                    ));
                    return true;
                }

                // Check that it exists on the source type
                if (!sourceMembers.Contains(member))
                {
                    var location = argument.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.InvalidPropertyName,
                        location,
                        member, namedSourceSymbol.Name
                    ));
                    return true;
                }

                return true;
            }

            // We've already validate 2 arguments
            Debug.Assert(attributeSyntax.ArgumentList is not null);

            // First arg is easy, it's the first syntax argument
            if (!ValidateAndAddMember(firstArg, attributeSyntax.ArgumentList!.Arguments[0]))
            {
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = memberBuilder.ToImmutableHashSet();
                return false;
            }

            if (paramsArg.Values.IsDefault)
            {
                // If paramsArg is a thing but is default that means the value is null
                var location = attributeSyntax.ArgumentList.Arguments[1].GetLocation();

                diagnosticsBuilder.Add(DiagnosticInfo.Create(
                    Diagnostics.NullArgument,
                    location,
                    "null"
                ));
                sourceType = namedSourceSymbol;
                targetType = namedTargetSymbol;
                diagnostics = diagnosticsBuilder;
                members = memberBuilder.ToImmutableHashSet();
                return true;
            }

            ImmutableArray<SyntaxNode> normalizedArguments;

            if (attributeSyntax.ArgumentList.Arguments is [_, var secondArg])
            {
                switch (secondArg.Expression)
                {
                    case CollectionExpressionSyntax collectionExpression:
                        normalizedArguments = collectionExpression.Elements.Select(e => (SyntaxNode)e).ToImmutableArray();
                        break;
                    case ArrayCreationExpressionSyntax arrayCreation:
                        if (arrayCreation.Initializer == null)
                        {
                            throw new InvalidOperationException("When can the array initializer be null?");
                        }

                        normalizedArguments = arrayCreation.Initializer.Expressions.Select(e => (SyntaxNode)e).ToImmutableArray();
                        break;
                    case ImplicitArrayCreationExpressionSyntax implicitArrayCreation:
                        normalizedArguments = implicitArrayCreation.Initializer.Expressions.Select(e => (SyntaxNode)e).ToImmutableArray();
                        break;
                    default:
                        normalizedArguments = ImmutableArray.Create<SyntaxNode>(secondArg);
                        break;
                }
            }
            else
            {
                normalizedArguments = attributeSyntax.ArgumentList.Arguments.Skip(1).Select(a => (SyntaxNode)a).ToImmutableArray();
            }

            for (int i = 0; i < paramsArg.Values.Length; i++)
            {
                TypedConstant paramArg = paramsArg.Values[i];
                var syntaxArgument = normalizedArguments[i];
                if (!ValidateAndAddMember(paramArg, syntaxArgument))
                {
                    sourceType = null;
                    targetType = null;
                    diagnostics = diagnosticsBuilder;
                    members = memberBuilder.ToImmutableHashSet();
                    return false;
                }
            }

            sourceType = namedSourceSymbol;
            targetType = namedTargetSymbol;
            diagnostics = diagnosticsBuilder;
            members = memberBuilder.ToImmutableHashSet();
            return true;
        }

        public static Result<PartialTypeSpec?> CreateOmit(GeneratorAttributeSyntaxContext context, CancellationToken token)
        {
            var (data, syntax) = context.GetSingleDataAndSyntax();
            return CreateOmit(context.TargetSymbol, data, syntax, true, token);
        }

        public static Result<PartialTypeSpec?> CreateOmit(ISymbol target, AttributeData attributeData, AttributeSyntax attributeSyntax, bool inSourceGenerator, CancellationToken token)
        {
            if (!TryCreate(
                target,
                attributeData,
                attributeSyntax,
                inSourceGenerator,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return new Result<PartialTypeSpec?>(null, diagnostics.ToImmutableArray().ToImmutableEquatableArray());
            }

            var targetTypeMembers = targetType.GetMembers()
                .Select(m => m.Name)
                .ToImmutableHashSet();

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var nonOmittedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => !members.Contains(ps.Name))
                    .Where(ps => !targetTypeMembers.Contains(ps.Name))
                    .ToImmutableArray();

                // TODO: Sometimes create a diagnostic for when we are running source generator mode
                // and a property that exists on the target type is specified in the attribute

                var constructors = sourceType.InstanceConstructors
                    .Select(c => TryGetDataConstructorArgs(c, nonOmittedProperties))
                    .Where(d => d != null)
                    .Select(d => d!)
                    .ToImmutableEquatableArray();

                return new Result<PartialTypeSpec?>(
                    new NonEnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Constructors = constructors,
                        Properties = nonOmittedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToSafeExactName(),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        }).ToImmutableEquatableArray(),
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var nonOmittedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => !members.Contains(fs.Name))
                    .Where(fs => !targetTypeMembers.Contains(fs.Name))
                    .ToImmutableArray();

                // TODO: Sometimes create a diagnostic when running in source generator mode
                // that a member name was given but it already exists on the target type

                return new Result<PartialTypeSpec?>(
                    new EnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Members = nonOmittedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        }).ToImmutableEquatableArray(),
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }

        private static ImmutableEquatableArray<ConstructorArgumentSpec>? TryGetDataConstructorArgs(IMethodSymbol constructor, ImmutableArray<IPropertySymbol> properties)
        {
            if (constructor.Parameters.Length == 0)
            {
                return null;
            }

            var candidate = ImmutableArray.CreateBuilder<ConstructorArgumentSpec>();
            foreach (var parameter in constructor.Parameters)
            {
                var prop = properties.FirstOrDefault(p => string.Equals(p.Name, parameter.Name, StringComparison.OrdinalIgnoreCase));

                if (prop == null)
                {
                    continue;
                }

                if (SymbolEqualityComparer.Default.Equals(parameter.Type, prop.Type))
                {
                    candidate.Add(new ConstructorArgumentSpec
                    {
                        ArgumentName = parameter.Name,
                        PropertyName = prop.Name,
                        Type = parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    });
                    continue;
                }
            }

            if (candidate.Count == 0)
            {
                return null;
            }

            return candidate.ToImmutableEquatableArray();
        }

        public static Result<PartialTypeSpec?> CreatePick(GeneratorAttributeSyntaxContext context, CancellationToken token)
        {
            var (data, syntax) = context.GetSingleDataAndSyntax();
            return CreatePick(context.TargetSymbol, data, syntax, true, token);
        }

        public static Result<PartialTypeSpec?> CreatePick(ISymbol target, AttributeData data, AttributeSyntax syntax, bool inSourceGenerator, CancellationToken token)
        {
            if (!TryCreate(
                target,
                data,
                syntax,
                inSourceGenerator,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return new Result<PartialTypeSpec?>(null, diagnostics.ToImmutableArray().ToImmutableEquatableArray());
            }

            token.ThrowIfCancellationRequested();

            var targetTypeMembers = targetType.GetMembers()
                .Select(m => m.Name)
                .ToImmutableHashSet();

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var pickedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => members.Contains(ps.Name))
                    .Where(ps => !targetTypeMembers.Contains(ps.Name))
                    .ToImmutableArray();

                // TODO: Sometimes create diagnostic when running in source generator mode
                // and the user has a member specified that already exists on the target type

                var constructors = sourceType.InstanceConstructors
                    .Select(c => TryGetDataConstructorArgs(c, pickedProperties))
                    .Where(c => c != null)
                    .Select(c => c!)
                    .ToImmutableEquatableArray();

                return new Result<PartialTypeSpec?>(
                    new NonEnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Constructors = constructors,
                        Properties = pickedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToSafeExactName(),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        }).ToImmutableEquatableArray(),
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var pickedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => members.Contains(fs.Name))
                    .Where(fs => !targetTypeMembers.Contains(fs.Name))
                    .ToImmutableArray();

                // TODO: Sometimes create diagnostic when running in source gen mode
                // and the user adds a member that already exists on the target type

                return new Result<PartialTypeSpec?>(
                    new EnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Members = pickedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        }).ToImmutableEquatableArray(),
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }

        public abstract TypeDeclarationSyntax Build(TypeDeclarationSyntax existing, TypeSyntax sourceType);

        public void Serialize(ImmutableDictionary<string, string?>.Builder destination)
        {
            if (this is NonEnumTypeSpec nonEnum)
            {
                destination.Add("type", "non-enum");
                destination.Add("props", string.Join(",", nonEnum.Properties.Select(p => p.Name)));

                foreach (var prop in nonEnum.Properties)
                {
                    destination.Add($"p:{prop.Name}", $"{prop.Type} {prop.SetAccess} {prop.IsRequired}");
                }

                // TODO: Constructors
            }
            else if (this is EnumTypeSpec enumType)
            {
                destination.Add("type", "enum");
            }
            else
            {
                throw new InvalidOperationException($"Cannot serialize {this.GetType().FullName}");
            }
        }

        public static PartialTypeSpec Deserialize(ImmutableDictionary<string, string?> properties)
        {
            if (!properties.TryGetValue("type", out var typeValue))
            {
                throw new InvalidOperationException("Could not find type");
            }

            if (typeValue == "non-enum")
            {
                var propsValue = properties["props"];
                if (propsValue == null)
                {
                    throw new InvalidOperationException($"props value is null");
                }

                var props = propsValue.Split(',');

                var typeProperties = new PropertySpec[props.Length];
                for (var i = 0; i < typeProperties.Length; i++)
                {
                    var prop = props[i];

                    if (!properties.TryGetValue($"p:{prop}", out var propValue))
                    {
                        throw new InvalidOperationException($"Property specified but no value");
                    }

                    if (propValue == null)
                    {
                        throw new InvalidOperationException("null prop value");
                    }

                    var propParts = propValue.Split(' ');

                    if (propParts.Length != 3)
                    {
                        throw new InvalidOperationException();
                    }

                    typeProperties[i] = new PropertySpec
                    {
                        Name = prop,
                        Type = propParts[0],
                        SetAccess = Enum.TryParse<SetAccess>(propParts[1], out var setAccess) ? setAccess : throw new InvalidOperationException(),
                        IsRequired = bool.Parse(propParts[2]),
                    };
                }

                return new NonEnumTypeSpec
                {
                    TargetType = null!,
                    SourceType = null!,
                    Properties = typeProperties.ToImmutableEquatableArray(),
                    Constructors = ImmutableEquatableArray<ImmutableEquatableArray<ConstructorArgumentSpec>>.Empty,
                };
            }
            else if (typeValue == "enum")
            {
                return new EnumTypeSpec
                {
                    TargetType = null!,
                    SourceType = null!,
                    Members = ImmutableEquatableArray<MemberSpec>.Empty,
                };
            }
            else
            {
                throw new InvalidOperationException($"Invalid type: {typeValue}");
            }
        }
    }

    internal sealed record NonEnumTypeSpec : PartialTypeSpec
    {
        public required ImmutableEquatableArray<ImmutableEquatableArray<ConstructorArgumentSpec>> Constructors { get; init; }
        public required ImmutableEquatableArray<PropertySpec> Properties { get; init; }

        public override bool HasChanges => Properties.Count > 0;

        public override IEnumerable<string> GetMemberNames()
        {
            return Properties.Select(p => p.Name);
        }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            for (var i = TargetType.Hierarchy.Count - 1; i >= 0; i--)
            {
                var type = TargetType.Hierarchy[i];
                writer.WriteLine($"partial {type.GetKindString()} {type.QualifiedName}");
                writer.WriteLine("{");
                writer.Indent++;

                if (i == 0)
                {
                    // Add constructors
                    foreach (var constructor in Constructors)
                    {
                        writer.WriteLine($"public {type.QualifiedName}({string.Join(", ", constructor.Select(a => $"{a.Type} {a.ArgumentName}"))})");
                        writer.WriteLine("{");
                        writer.Indent++;
                        // TODO: Assign properties
                        foreach (var a in constructor)
                        {
                            writer.WriteLine($"{(a.NeedsQualification ? "this." : "")}{a.PropertyName} = {a.ArgumentName};");
                        }
                        writer.Indent--;
                        writer.WriteLine("}");
                        writer.WriteLineNoTabs("");
                    }

                    // Add members
                    foreach (var property in Properties)
                    {
                        writer.WriteLine($"/// <inheritdoc cref=\"{SourceType.GlobalName()}.{property.Name}\"/>");
                        writer.WriteLine($"public{(property.IsRequired ? " required " : " ")}{property.Type} {property.Name} {{ get;{GetSetString(property.SetAccess)}}}");
                    }
                }
            }

            for (var i = 0; i < TargetType.Hierarchy.Count; i++)
            {
                // Close types
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        public override TypeDeclarationSyntax Build(TypeDeclarationSyntax existing, TypeSyntax sourceType)
        {
            var properties = Properties.Select(p =>
            {
                var accessors = List([AccessorDeclaration(SyntaxKind.GetAccessorDeclaration).WithSemicolonToken(Token(SyntaxKind.SemicolonToken))]);
                if (p.SetAccess == SetAccess.Init)
                {
                    accessors = accessors.Add(AccessorDeclaration(SyntaxKind.InitAccessorDeclaration).WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                }
                else if (p.SetAccess == SetAccess.Set)
                {
                    accessors = accessors.Add(AccessorDeclaration(SyntaxKind.SetAccessorDeclaration).WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
                }

                var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));

                if (p.IsRequired)
                {
                    modifiers = modifiers.Add(Token(SyntaxKind.RequiredKeyword));
                }

                return PropertyDeclaration(
                    attributeLists: List<AttributeListSyntax>(),
                    modifiers: modifiers,
                    type: ParseTypeName(p.Type),
                    explicitInterfaceSpecifier: null,
                    identifier: Identifier(p.Name),
                    accessorList: AccessorList(accessors)
                ).WithLeadingTrivia(
                    TriviaList(
                        Trivia(DocumentationComment(
                            XmlEmptyElement(
                                XmlName("inheritdoc"),
                                List<XmlAttributeSyntax>([
                                    XmlCrefAttribute(QualifiedCref(sourceType, NameMemberCref(ParseTypeName(p.Name))))
                                ])
                            )
                        )),
                        LineFeed
                    )
                );
            });

            return existing
                .WithOpenBraceToken(Token(SyntaxKind.OpenBraceToken))
                .WithMembers(
                    List<MemberDeclarationSyntax>(properties)
                )
                .WithCloseBraceToken(Token(SyntaxKind.CloseBraceToken));
        }

        private string GetSetString(SetAccess setAccess)
        {
            return setAccess switch
            {
                SetAccess.Set => " set; ",
                SetAccess.Init => " init; ",
                SetAccess.None => " ",
                _ => throw new Exception("Unreachable"),
            };
        }
    }

    internal sealed record EnumTypeSpec : PartialTypeSpec
    {
        public required ImmutableEquatableArray<MemberSpec> Members { get; init; }
        public override bool HasChanges => Members.Count > 0;

        public override TypeDeclarationSyntax Build(TypeDeclarationSyntax existing, TypeSyntax sourceType)
        {
            throw new NotImplementedException();
        }

        public override IEnumerable<string> GetMemberNames()
        {
            return Members.Select(m => m.Name);
        }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            writer.WriteLine($"partial enum {TargetType.MetadataName}");
            writer.WriteLine("{");
            writer.Indent++;

            // Add members
            foreach (var member in Members)
            {
                writer.WriteLine($"/// <inheritdoc cref=\"{SourceType.GlobalName()}.{member.Name}\"/>");
                writer.Write($"{member.Name}");
                if (member.Value != null)
                {
                    writer.Write($" = {member.Value}");
                }
                writer.WriteLine(",");
            }

            writer.Indent--;
            writer.WriteLine("}");
        }
    }

    public enum SetAccess
    {
        None,
        Set,
        Init,
    }

    internal interface IMemberSpec
    {
        string Name { get; }
    }

    internal sealed record PropertySpec : IMemberSpec
    {
        public required string Type { get; init; }
        public required string Name { get; init; }
        public required bool IsRequired { get; init; }
        public required SetAccess SetAccess { get; init; }
    }

    internal sealed record ConstructorArgumentSpec
    {
        public required string ArgumentName { get; init; }
        public required string PropertyName { get; init; }
        public required string Type { get; init; }

        public bool NeedsQualification
        {
            get => ArgumentName == PropertyName;
        }
    }

    internal sealed record MemberSpec : IMemberSpec
    {
        public required string Name { get; init; }
        public required string? Value { get; init; }
    }
}