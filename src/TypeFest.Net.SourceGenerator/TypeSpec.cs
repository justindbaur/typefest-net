using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis;
using TypeFest.Net.SourceGenerator.Utilities;

namespace TypeFest.Net.SourceGenerator
{
    internal abstract record PartialTypeSpec
    {
        public required HierarchyInfo TargetType { get; init; }
        public required HierarchyInfo SourceType { get; init; }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");

            if (TargetType.Namespace is not "")
            {
                writer.WriteLine($"namespace {TargetType.Namespace}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            EmitCore(writer);

            if (TargetType.Namespace is not "")
            {
                writer.Indent--;
                writer.Write("}");
            }
        }

        protected abstract void EmitCore(IndentedTextWriter writer);

        private static bool TryCreate(
            ISymbol targetSymbol,
            AttributeData attributeData,
            [NotNullWhen(true)] out INamedTypeSymbol? targetType,
            [NotNullWhen(true)] out INamedTypeSymbol? sourceType,
            [NotNullWhen(true)] out ImmutableHashSet<string>? members,
            out ImmutableArray<DiagnosticInfo>.Builder diagnostics)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new InvalidOperationException("Target type is not a named type symbol, I think this should be impossible.");
            }

            if (attributeData.AttributeClass == null)
            {
                throw new InvalidOperationException("AttributeData is expected to have a attribute class at this point, how did this happen?");
            }

            if (attributeData.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedSourceSymbol)
            {
                throw new InvalidOperationException("Expected a single, named type argument for one of our attributes.");
            }

            if (attributeData.ConstructorArguments is not [var firstArg, var paramsArg])
            {
                throw new InvalidOperationException($"Expected two args but instead got {attributeData.ConstructorArguments.Length}.");
            }

            if (paramsArg.Kind != TypedConstantKind.Array)
            {
                throw new InvalidOperationException("Expected an array for the second argument.");
            }

            var diagnosticsBuilder = ImmutableArray.CreateBuilder<DiagnosticInfo>();

            // We do allow a struct -> class and class -> struct
            if ((namedSourceSymbol.TypeKind == TypeKind.Enum && namedTargetSymbol.TypeKind != TypeKind.Enum)
                || (namedSourceSymbol.TypeKind != TypeKind.Enum && namedTargetSymbol.TypeKind == TypeKind.Enum))
            {
                var location = attributeData.GetLocation();
                diagnosticsBuilder.Add(DiagnosticInfo.Create(
                    Diagnostics.InvalidTypeKind,
                    location,
                    namedTargetSymbol.TypeKind, namedSourceSymbol.TypeKind
                ));
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = null;
                return false;
            }

            var memberBuilder = ImmutableHashSet.CreateBuilder<string>();

            ImmutableHashSet<string> sourceMembers;
            if (namedSourceSymbol.TypeKind == TypeKind.Enum)
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Select(fs => fs.Name)
                    .ToImmutableHashSet();
            }
            else
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Select(ps => ps.Name)
                    .ToImmutableHashSet();
            }

            bool ValidateAndAddMember(TypedConstant typedConstant)
            {
                if (typedConstant.IsNull)
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.NullArgument,
                        location,
                        "null"
                    ));
                    return true;
                }

                var member = (string)typedConstant.Value!;

                if (!memberBuilder.Add(member))
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.DuplicateArgument,
                        location,
                        member
                    ));
                    return true;
                }

                // Check that it exists on the source type
                if (!sourceMembers.Contains(member))
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(DiagnosticInfo.Create(
                        Diagnostics.InvalidPropertyName,
                        location,
                        member, namedSourceSymbol.Name
                    ));
                    return true;
                }

                return true;
            }

            if (!ValidateAndAddMember(firstArg))
            {
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = memberBuilder.ToImmutableHashSet();
                return false;
            }

            if (paramsArg.Values.IsDefault)
            {
                // If paramsArg is a thing but is default that means the value is null
                // TODO: Get location more specific to this argument
                var location = attributeData.GetLocation();

                diagnosticsBuilder.Add(DiagnosticInfo.Create(
                    Diagnostics.NullArgument,
                    location,
                    "null"
                ));
                sourceType = namedSourceSymbol;
                targetType = namedTargetSymbol;
                diagnostics = diagnosticsBuilder;
                members = memberBuilder.ToImmutableHashSet();
                return true;
            }

            foreach (var paramArg in paramsArg.Values)
            {
                if (!ValidateAndAddMember(paramArg))
                {
                    sourceType = null;
                    targetType = null;
                    diagnostics = diagnosticsBuilder;
                    members = memberBuilder.ToImmutableHashSet();
                    return false;
                }
            }

            sourceType = namedSourceSymbol;
            targetType = namedTargetSymbol;
            diagnostics = diagnosticsBuilder;
            members = memberBuilder.ToImmutableHashSet();
            return true;
        }

        public static Result<PartialTypeSpec?> CreateOmit(ISymbol targetSymbol, AttributeData attributeData)
        {
            // TODO: Validate more closely that it's _our_ OmitAttribute
            if (!TryCreate(
                targetSymbol,
                attributeData,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return new Result<PartialTypeSpec?>(null, diagnostics.ToImmutableArray().ToImmutableEquatableArray());
            }

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var nonOmittedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => !members.Contains(ps.Name))
                    .ToImmutableArray();

                var constructors = sourceType.InstanceConstructors
                    .Select(c => TryGetDataConstructorArgs(c, nonOmittedProperties))
                    .Where(d => d != null)
                    .Select(d => d!)
                    .ToImmutableEquatableArray();

                return new Result<PartialTypeSpec?>(
                    new NonEnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Constructors = constructors,
                        Properties = [.. nonOmittedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var nonOmittedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => !members.Contains(fs.Name))
                    .ToImmutableArray();

                return new Result<PartialTypeSpec?>(
                    new EnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Members = [.. nonOmittedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }

        private static ImmutableEquatableArray<ConstructorArgumentSpec>? TryGetDataConstructorArgs(IMethodSymbol constructor, ImmutableArray<IPropertySymbol> properties)
        {
            if (constructor.Parameters.Length == 0)
            {
                return null;
            }

            var candidate = ImmutableArray.CreateBuilder<ConstructorArgumentSpec>();
            foreach (var parameter in constructor.Parameters)
            {
                var prop = properties.FirstOrDefault(p => string.Equals(p.Name, parameter.Name, StringComparison.OrdinalIgnoreCase));

                if (prop == null)
                {
                    continue;
                }

                if (SymbolEqualityComparer.Default.Equals(parameter.Type, prop.Type))
                {
                    candidate.Add(new ConstructorArgumentSpec
                    {
                        ArgumentName = parameter.Name,
                        PropertyName = prop.Name,
                        Type = parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    });
                    continue;
                }
            }

            if (candidate.Count == 0)
            {
                return null;
            }

            return candidate.ToImmutableEquatableArray();
        }

        public static Result<PartialTypeSpec?> CreatePick(ISymbol targetSymbol, AttributeData attributeData)
        {
            // TODO: Validate more closely that it's _our_ PickAttribute
            if (!TryCreate(
                targetSymbol,
                attributeData,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return new Result<PartialTypeSpec?>(null, diagnostics.ToImmutableArray().ToImmutableEquatableArray());
            }

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var pickedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => members.Contains(ps.Name))
                    .ToImmutableArray();

                var constructors = sourceType.InstanceConstructors
                    .Select(c => TryGetDataConstructorArgs(c, pickedProperties))
                    .Where(c => c != null)
                    .Select(c => c!)
                    .ToImmutableEquatableArray();

                return new Result<PartialTypeSpec?>(
                    new NonEnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Constructors = constructors,
                        Properties = [.. pickedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var pickedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => members.Contains(fs.Name))
                    .ToImmutableArray();

                return new Result<PartialTypeSpec?>(
                    new EnumTypeSpec
                    {
                        SourceType = HierarchyInfo.From(sourceType),
                        TargetType = HierarchyInfo.From(targetType),
                        Members = [.. pickedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray().ToImmutableEquatableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }
    }

    internal sealed record NonEnumTypeSpec : PartialTypeSpec
    {
        public required ImmutableEquatableArray<ImmutableEquatableArray<ConstructorArgumentSpec>> Constructors { get; init; }
        public required IReadOnlyList<PropertySpec> Properties { get; init; }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            for (var i = TargetType.Hierarchy.Count - 1; i >= 0; i--)
            {
                var type = TargetType.Hierarchy[i];
                writer.WriteLine($"partial {type.GetKindString()} {type.QualifiedName}");
                writer.WriteLine("{");
                writer.Indent++;

                if (i == 0)
                {
                    // Add constructors
                    foreach (var constructor in Constructors)
                    {
                        writer.WriteLine($"public {type.QualifiedName}({string.Join(", ", constructor.Select(a => $"{a.Type} {a.ArgumentName}"))})");
                        writer.WriteLine("{");
                        writer.Indent++;
                        // TODO: Assign properties
                        foreach (var a in constructor)
                        {
                            writer.WriteLine($"{(a.NeedsQualification ? "this." : "")}{a.PropertyName} = {a.ArgumentName};");
                        }
                        writer.Indent--;
                        writer.WriteLine("}");
                        writer.WriteLineNoTabs("");
                    }

                    // Add members
                    foreach (var property in Properties)
                    {
                        writer.WriteLine($"/// <inheritdoc cref=\"{SourceType.GlobalName()}.{property.Name}\" />");
                        writer.WriteLine($"public{(property.IsRequired ? " required " : " ")}{property.Type} {property.Name} {{ get;{GetSetString(property.SetAccess)}}}");
                    }
                }
            }

            for (var i = 0; i < TargetType.Hierarchy.Count; i++)
            {
                // Close types
                writer.Indent--;
                writer.WriteLine("}");
            }
        }

        private string GetSetString(SetAccess setAccess)
        {
            return setAccess switch
            {
                SetAccess.Set => " set; ",
                SetAccess.Init => " init; ",
                SetAccess.None => " ",
                _ => throw new Exception("Unreachable"),
            };
        }
    }

    internal sealed record EnumTypeSpec : PartialTypeSpec
    {
        public required IReadOnlyList<MemberSpec> Members { get; init; }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            writer.WriteLine($"partial enum {TargetType.MetadataName}");
            writer.WriteLine("{");
            writer.Indent++;

            // Add members
            foreach (var member in Members)
            {
                writer.WriteLine($"/// <inheritdoc cref=\"{SourceType.GlobalName()}.{member.Name}\" />");
                writer.Write($"{member.Name}");
                if (member.Value != null)
                {
                    writer.Write($" = {member.Value}");
                }
                writer.WriteLine(",");
            }

            writer.Indent--;
            writer.WriteLine("}");
        }
    }

    public enum SetAccess
    {
        None,
        Set,
        Init,
    }

    internal sealed record PropertySpec
    {
        public required string Type { get; init; }
        public required string Name { get; init; }
        public required bool IsRequired { get; init; }
        public required SetAccess SetAccess { get; init; }
    }

    internal sealed record ConstructorArgumentSpec
    {
        public required string ArgumentName { get; init; }
        public required string PropertyName { get; init; }
        public required string Type { get; init; }

        public bool NeedsQualification
        {
            get => ArgumentName == PropertyName;
        }
    }

    internal sealed record MemberSpec
    {
        public required string Name { get; init; }
        public required string? Value { get; init; }
    }
}