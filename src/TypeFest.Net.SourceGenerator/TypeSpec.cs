using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace TypeFest.Net.SourceGenerator
{
    public enum SpecKind
    {
        Class,
        Struct,
        Record,
        RecordStruct,
    }

    public abstract record PartialTypeSpec
    {
        public string FullName
        {
            get
            {
                return $"{string.Join(".", Namespace)}.{Name}";
            }
        }
        public required string SourceType { get; init; }
        public required ImmutableArray<string> Namespace { get; init; }
        public required string Name { get; init; }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");

            foreach (var ns in Namespace)
            {
                writer.WriteLine($"namespace {ns}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            EmitCore(writer);

            for (int i = 0; i < Namespace.Length; i++)
            {
                writer.Indent--;
                if (i == Namespace.Length - 1)
                {
                    writer.Write("}");
                }
                else
                {
                    writer.WriteLine("}");
                }
            }
        }

        protected abstract void EmitCore(IndentedTextWriter writer);

        private static bool TryCreate(
            ISymbol targetSymbol,
            AttributeData attributeData,
            [NotNullWhen(true)] out INamedTypeSymbol? targetType,
            [NotNullWhen(true)] out INamedTypeSymbol? sourceType,
            [NotNullWhen(true)] out ImmutableHashSet<string>? members,
            out ImmutableArray<Diagnostic>.Builder diagnostics)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new InvalidOperationException("Target type is not a named type symbol, I think this should be impossible.");
            }

            if (attributeData.AttributeClass == null)
            {
                throw new InvalidOperationException("AttributeData is expected to have a attribute class at this point, how did this happen?");
            }

            if (attributeData.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedSourceSymbol)
            {
                throw new InvalidOperationException("Expected a single, named type argument for one of our attributes.");
            }

            if (attributeData.ConstructorArguments is not [var firstArg, var paramsArg])
            {
                throw new InvalidOperationException($"Expected two args but instead got {attributeData.ConstructorArguments.Length}.");
            }

            if (paramsArg.Kind != TypedConstantKind.Array)
            {
                throw new InvalidOperationException("Expected an array for the second argument.");
            }

            var diagnosticsBuilder = ImmutableArray.CreateBuilder<Diagnostic>();

            // We do allow a struct -> class and class -> struct
            if ((namedSourceSymbol.TypeKind == TypeKind.Enum && namedTargetSymbol.TypeKind != TypeKind.Enum)
                || (namedSourceSymbol.TypeKind != TypeKind.Enum && namedTargetSymbol.TypeKind == TypeKind.Enum))
            {
                var location = attributeData.GetLocation();
                diagnosticsBuilder.Add(Diagnostic.Create(
                    Diagnostics.InvalidTypeKind,
                    location,
                    messageArgs: [namedTargetSymbol.TypeKind, namedSourceSymbol.TypeKind]
                ));
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = null;
                return false;
            }

            var memberBuilder = ImmutableHashSet.CreateBuilder<string>();

            ImmutableHashSet<string> sourceMembers;
            if (namedSourceSymbol.TypeKind == TypeKind.Enum)
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Select(fs => fs.Name)
                    .ToImmutableHashSet();
            }
            else
            {
                sourceMembers = namedSourceSymbol.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Select(ps => ps.Name)
                    .ToImmutableHashSet();
            }

            bool ValidateAndAddMember(TypedConstant typedConstant)
            {
                if (typedConstant.IsNull)
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(Diagnostic.Create(
                        Diagnostics.NullArgument,
                        location,
                        messageArgs: "null"
                    ));
                    return false;
                }

                var member = (string)typedConstant.Value!;

                if (!memberBuilder.Add(member))
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(Diagnostic.Create(
                        Diagnostics.DuplicateArgument,
                        location,
                        messageArgs: member
                    ));
                    return true;
                }

                // Check that it exists on the source type
                if (!sourceMembers.Contains(member))
                {
                    // TODO: Get location more specific to this argument
                    var location = attributeData.GetLocation();

                    diagnosticsBuilder.Add(Diagnostic.Create(
                        Diagnostics.InvalidPropertyName,
                        location,
                        messageArgs: [member, namedSourceSymbol.Name]
                    ));
                    return true;
                }

                return true;
            }

            if (!ValidateAndAddMember(firstArg))
            {
                sourceType = null;
                targetType = null;
                diagnostics = diagnosticsBuilder;
                members = memberBuilder.ToImmutableHashSet();
                return false;
            }

            foreach (var paramArg in paramsArg.Values)
            {
                if (!ValidateAndAddMember(paramArg))
                {
                    sourceType = null;
                    targetType = null;
                    diagnostics = diagnosticsBuilder;
                    members = memberBuilder.ToImmutableHashSet();
                    return false;
                }
            }

            sourceType = namedSourceSymbol;
            targetType = namedTargetSymbol;
            diagnostics = diagnosticsBuilder;
            members = memberBuilder.ToImmutableHashSet();
            return true;
        }

        public static (PartialTypeSpec? Spec, ImmutableArray<Diagnostic> Diagnostics) CreateOmit(ISymbol targetSymbol, AttributeData attributeData)
        {
            // TODO: Validate more closely that it's _our_ OmitAttribute
            if (!TryCreate(
                targetSymbol,
                attributeData,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return (null, diagnostics.ToImmutableArray());
            }

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var nonOmittedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => !members.Contains(ps.Name))
                    .ToImmutableArray();

                return (
                    new NonEnumTypeSpec
                    {
                        SourceType = sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        Kind = targetType.IsRecord
                            ? targetType.TypeKind == TypeKind.Struct
                                ? SpecKind.RecordStruct
                                : SpecKind.Record
                            : targetType.TypeKind == TypeKind.Struct
                                ? SpecKind.Struct
                                : SpecKind.Class,
                        Namespace = targetType.GetNamespaceParts(),
                        // TODO: Full namespace but no global
                        Name = targetType.ToDisplayString(NullableFlowState.None, SymbolDisplayFormat.MinimallyQualifiedFormat),
                        Properties = [.. nonOmittedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var nonOmittedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => !members.Contains(fs.Name))
                    .ToImmutableArray();

                return (
                    new EnumTypeSpec
                    {
                        SourceType = sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        Name = targetType.ToDisplayString(NullableFlowState.None, SymbolDisplayFormat.MinimallyQualifiedFormat),
                        Namespace = targetType.GetNamespaceParts(),
                        Members = [..nonOmittedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }

        public static (PartialTypeSpec? Spec, ImmutableArray<Diagnostic> Diagnostics) CreatePick(ISymbol targetSymbol, AttributeData attributeData)
        {
            // TODO: Validate more closely that it's _our_ PickAttribute
            if (!TryCreate(
                targetSymbol,
                attributeData,
                out var targetType,
                out var sourceType,
                out var members,
                out var diagnostics))
            {
                return (null, diagnostics.ToImmutableArray());
            }

            if (targetType.TypeKind is TypeKind.Class or TypeKind.Struct)
            {
                var pickedProperties = sourceType.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(ps => ps.DeclaredAccessibility == Accessibility.Public)
                    .Where(ps => members.Contains(ps.Name))
                    .ToImmutableArray();

                return (
                    new NonEnumTypeSpec
                    {
                        SourceType = sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        Kind = targetType.IsRecord
                            ? targetType.TypeKind == TypeKind.Struct
                                ? SpecKind.RecordStruct
                                : SpecKind.Record
                            : targetType.TypeKind == TypeKind.Struct
                                ? SpecKind.Struct
                                : SpecKind.Class,
                        // TODO: Full namespace but no global
                        Name = targetType.ToDisplayString(NullableFlowState.None, SymbolDisplayFormat.MinimallyQualifiedFormat),
                        Namespace = targetType.GetNamespaceParts(),
                        Properties = [.. pickedProperties.Select(ps =>
                        {
                            return new PropertySpec
                            {
                                Name = ps.Name,
                                // global qualified type name, will null annotations
                                Type = ps.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                IsRequired = ps.IsRequired,
                                SetAccess = ps.SetMethod == null
                                    ? SetAccess.None
                                    : ps.SetMethod.IsInitOnly
                                        ? SetAccess.Init
                                        : SetAccess.Set,
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray()
                );
            }
            else if (targetType.TypeKind == TypeKind.Enum)
            {
                var pickedFields = sourceType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(fs => members.Contains(fs.Name))
                    .ToImmutableArray();

                return (
                    new EnumTypeSpec
                    {
                        SourceType = sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        Name = targetType.ToDisplayString(NullableFlowState.None, SymbolDisplayFormat.MinimallyQualifiedFormat),
                        Namespace = targetType.GetNamespaceParts(),
                        Members = [..pickedFields.Select(fs =>
                        {
                            return new MemberSpec
                            {
                                Name = fs.Name,
                                Value = fs.ConstantValue?.ToString()
                            };
                        })],
                    },
                    diagnostics.ToImmutableArray()
                );
            }
            else
            {
                throw new InvalidOperationException($"TypeKind of {targetType.TypeKind} is not supported.");
            }
        }
    }

    public record NonEnumTypeSpec : PartialTypeSpec
    {
        public required SpecKind Kind { get; init; }
        public required IReadOnlyList<PropertySpec> Properties { get; init; }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            writer.WriteLine($"partial {ToKindString()} {Name}");
            writer.WriteLine("{");
            writer.Indent++;

            // Add members
            foreach (var property in Properties)
            {
                writer.WriteLine($"/// <inheritdoc cref=\"{SourceType}.{property.Name}\" />");
                writer.WriteLine($"public {property.Type} {property.Name} {{ get;{GetSetString(property.SetAccess)}}}");
            }

            writer.Indent--;
            writer.WriteLine("}");
        }

        private string GetSetString(SetAccess setAccess)
        {
            return setAccess switch
            {
                SetAccess.Set => " set; ",
                SetAccess.Init => " init; ",
                SetAccess.None => "",
                _ => throw new Exception("Unreachable"),
            };
        }

        private string ToKindString()
        {
            return Kind switch
            {
                SpecKind.Class => "class",
                SpecKind.Record => "record",
                SpecKind.Struct => "struct",
                SpecKind.RecordStruct => "record struct",
                _ => throw new Exception("Unreachable"),
            };
        }
    }

    public record EnumTypeSpec : PartialTypeSpec
    {
        public required IReadOnlyList<MemberSpec> Members { get; init; }

        protected override void EmitCore(IndentedTextWriter writer)
        {
            writer.WriteLine($"partial enum {Name}");
            writer.WriteLine("{");
            writer.Indent++;

            // Add members
            foreach (var member in Members)
            {
                writer.WriteLine($"/// <inheritdoc cref=\"{SourceType}.{member.Name}\" />");
                writer.Write($"{member.Name}");
                if (member.Value != null)
                {
                    writer.Write($" = {member.Value}");
                }
                writer.WriteLine(",");
            }

            writer.Indent--;
            writer.WriteLine("}");
        }
    }

    public enum SetAccess
    {
        None,
        Set,
        Init,
    }

    public record PropertySpec
    {
        public required string Type { get; init; }
        public required string Name { get; init; }
        public required bool IsRequired { get; init; }
        public required SetAccess SetAccess { get; init; }
    }

    public record MemberSpec
    {
        public required string Name { get; init; }
        public required string? Value { get; init; }
    }
}