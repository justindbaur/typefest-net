using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace TypeFest.Net.SourceGenerator
{
    public record MapTypeInfo
    {
        public required string Name { get; init; }
    }

    public class MapInfo
    {
        // TODO: Allow customization
        public required ImmutableArray<string> Namespace { get; init; }
        public required string MethodName { get; init; }
        public required string SourceType { get; init; }
        public required string ReturnType { get; init; }
        public required bool IsIntoMode { get; init; }

        // TODO: Support customization of which properties to which
        public required ImmutableArray<(string Left, string Right)> Members { get; init; }

        public static (MapInfo? MapInfo, ImmutableArray<Diagnostic> Diagnostics) Create(ISymbol targetSymbol, AttributeData attribute, bool isInto)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass == null)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedTypeArgument)
            {
                throw new Exception();
            }

            IEnumerable<IPropertySymbol> props = namedTargetSymbol
                .GetMembers()
                .OfType<IPropertySymbol>();

            if (attribute.NamedArguments.SingleOrDefault((arg) => arg.Key == "Ignore") is KeyValuePair<string, TypedConstant> ignoreMembers
                && !ignoreMembers.Value.IsNull)
            {
                var ignoredNames = ignoreMembers.Value.Values.Select(
                    tc => (string?)tc.Value
                );

                // TODO: Diagnostics on invalid ignored names here
                props = props
                    .Where(ps => !ignoredNames.Contains(ps.Name));
            }

            var sourceType = isInto
                ? namedTargetSymbol
                : namedTypeArgument;
            
            var returnType = isInto
                ? namedTypeArgument
                : namedTargetSymbol;

            var methodName = isInto
                ? $"Into{returnType.Name}"
                : $"From{sourceType.Name}";

            return (
                new MapInfo
                {
                    Namespace = namedTargetSymbol.GetNamespaceParts(),
                    IsIntoMode = isInto,
                    SourceType = sourceType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                    ReturnType = returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    MethodName = methodName,
                    Members = [.. props.Select(ps => (ps.Name, ps.Name))],
                },
                ImmutableArray<Diagnostic>.Empty
            );
        }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");

            foreach (var ns in Namespace)
            {
                writer.WriteLine($"namespace {ns}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            // TODO: Needs to be able to be struct as well
            writer.WriteLine($"partial class {SourceType}");
            writer.WriteLine("{");
            writer.Indent++;

            // Start method
            writer.WriteLine($"public {ReturnType} {MethodName}()");
            writer.WriteLine("{");
            writer.Indent++;

            // TODO: Do mapping
            writer.WriteLine($"return new {ReturnType}");
            writer.WriteLine("{");
            writer.Indent++;

            foreach (var (left, right) in Members)
            {
                writer.WriteLine($"{left} = {right},");
            }

            // Close object creation
            writer.Indent--;
            writer.WriteLine("};");
            
            // Close method
            writer.Indent--;
            writer.WriteLine("}");

            // Close type
            writer.Indent--;
            writer.WriteLine("}");

            for (int i = 0; i < Namespace.Length; i++)
            {
                writer.Indent--;
                if (i == Namespace.Length - 1)
                {
                    writer.Write("}");
                }
                else
                {
                    writer.WriteLine("}");
                }
            }
        }
    }
}