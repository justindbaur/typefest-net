using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace TypeFest.Net.SourceGenerator
{
    internal sealed record MapInfo
    {
        public required HierarchyInfo PartialType { get; init; }
        public required HierarchyInfo GenericType { get; init; }
        public required bool IsInto { get; init; }

        // TODO: Support customization of which properties to which
        public required ImmutableEquatableArray<string> Members { get; init; }

        public static (MapInfo? MapInfo, ImmutableArray<DiagnosticInfo> Diagnostics) Create(ISymbol targetSymbol, AttributeData attribute, bool isInto)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass == null)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedTypeArgument)
            {
                throw new Exception();
            }

            IEnumerable<IPropertySymbol> props = namedTargetSymbol
                .GetMembers()
                .OfType<IPropertySymbol>();

            if (attribute.NamedArguments.SingleOrDefault((arg) => arg.Key == "Ignore") is KeyValuePair<string, TypedConstant> ignoreMembers
                && !ignoreMembers.Value.IsNull)
            {
                var ignoredNames = ignoreMembers.Value.Values.Select(
                    tc => (string?)tc.Value
                );

                // TODO: Diagnostics on invalid ignored names here
                props = props
                    .Where(ps => !ignoredNames.Contains(ps.Name));
            }

            return (
                new MapInfo
                {
                    IsInto = isInto,
                    PartialType = HierarchyInfo.From(namedTargetSymbol),
                    GenericType = HierarchyInfo.From(namedTypeArgument),
                    Members = props.Select(ps => ps.Name).ToImmutableEquatableArray(),
                },
                ImmutableArray<DiagnosticInfo>.Empty
            );
        }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");

            if (PartialType.Namespace is not "")
            {
                writer.WriteLine($"namespace {PartialType.Namespace}");
                writer.WriteLine("{");
                writer.Indent++;
            }


            // All but the base type
            for (var i = PartialType.Hierarchy.Count - 1; i >= 0; i--)
            {
                var type = PartialType.Hierarchy[i];
                writer.WriteLine($"partial {type.GetKindString()} {type.QualifiedName}");
                writer.WriteLine("{");
                writer.Indent++;

                if (i == 0)
                {
                    // Start method
                    if (IsInto)
                    {
                        writer.WriteLine($"public {GenericType.GlobalName()} Into{GenericType.MetadataName}()");
                    }
                    else
                    {
                        // TODO: Do I need to put global in front?
                        writer.WriteLine($"public static {PartialType.GlobalName()} From{GenericType.MetadataName}({GenericType.GlobalName()} value)");
                    }
                    writer.WriteLine("{");
                    writer.Indent++;

                    // TODO: Do mapping
                    if (IsInto)
                    {
                        writer.WriteLine($"return new {GenericType.GlobalName()}");
                    }
                    else
                    {
                        writer.WriteLine($"return new {PartialType.GlobalName()}");
                    }
                    writer.WriteLine("{");
                    writer.Indent++;

                    foreach (var member in Members)
                    {
                        if (IsInto)
                        {
                            writer.WriteLine($"{member} = {member},");
                        }
                        else
                        {
                            writer.WriteLine($"{member} = value.{member},");
                        }
                    }

                    // Close object creation
                    writer.Indent--;
                    writer.WriteLine("};");

                    // Close method
                    writer.Indent--;
                    writer.WriteLine("}");
                }
            }

            for (var i = 0; i < PartialType.Hierarchy.Count; i++)
            {
                // Close types
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (PartialType.Namespace is not "")
            {
                writer.Indent--;
                writer.Write("}");
            }
        }
    }
}