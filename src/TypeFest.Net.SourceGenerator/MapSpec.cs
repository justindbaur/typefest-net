using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace TypeFest.Net.SourceGenerator
{
    // Into: Need to be able to make the full type definition of the type
    // but don't need to mention it fully qualified
    // From: 
    internal sealed record MapTypeInfo(
        TypeKind TypeKind,
        bool IsRecord,
        ImmutableEquatableArray<string> Namespaces,
        string Name,
        string QualifiedName
    )
    {
        public static MapTypeInfo FromTypeSymbol(INamedTypeSymbol typeSymbol)
        {
            return new MapTypeInfo(
                typeSymbol.TypeKind,
                typeSymbol.IsRecord,
                typeSymbol.GetNamespaceParts(),
                typeSymbol.Name,
                typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            );
        }
    }

    internal sealed record MapInfo
    {
        public required MapTypeInfo PartialType { get; init; }
        public required MapTypeInfo GenericType { get; init; }
        public required bool IsInto { get; init; }

        // TODO: Support customization of which properties to which
        public required ImmutableEquatableArray<string> Members { get; init; }

        public static (MapInfo? MapInfo, ImmutableArray<Diagnostic> Diagnostics) Create(ISymbol targetSymbol, AttributeData attribute, bool isInto)
        {
            if (targetSymbol is not INamedTypeSymbol namedTargetSymbol)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass == null)
            {
                throw new Exception();
            }

            if (attribute.AttributeClass.TypeArguments is not [var singleTypeArg]
                || singleTypeArg is not INamedTypeSymbol namedTypeArgument)
            {
                throw new Exception();
            }

            IEnumerable<IPropertySymbol> props = namedTargetSymbol
                .GetMembers()
                .OfType<IPropertySymbol>();

            if (attribute.NamedArguments.SingleOrDefault((arg) => arg.Key == "Ignore") is KeyValuePair<string, TypedConstant> ignoreMembers
                && !ignoreMembers.Value.IsNull)
            {
                var ignoredNames = ignoreMembers.Value.Values.Select(
                    tc => (string?)tc.Value
                );

                // TODO: Diagnostics on invalid ignored names here
                props = props
                    .Where(ps => !ignoredNames.Contains(ps.Name));
            }

            return (
                new MapInfo
                {
                    IsInto = isInto,
                    PartialType = MapTypeInfo.FromTypeSymbol(namedTargetSymbol),
                    GenericType = MapTypeInfo.FromTypeSymbol(namedTypeArgument),
                    Members = props.Select(ps => ps.Name).ToImmutableEquatableArray(),
                },
                ImmutableArray<Diagnostic>.Empty
            );
        }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine("// <auto-generated/>");

            foreach (var ns in PartialType.Namespaces)
            {
                writer.WriteLine($"namespace {ns}");
                writer.WriteLine("{");
                writer.Indent++;
            }

            // TODO: Needs to be able to be struct as well
            var kindString = PartialType.TypeKind switch
            {
                TypeKind.Class => PartialType.IsRecord ? "record" : "class",
                TypeKind.Struct => PartialType.IsRecord ? "record struct" : "struct",
                _ => throw new NotImplementedException(),
            };
            writer.WriteLine($"partial {kindString} {PartialType.Name}");
            writer.WriteLine("{");
            writer.Indent++;

            // Start method
            if (IsInto)
            {
                writer.WriteLine($"public {GenericType.QualifiedName} Into{GenericType.Name}()");
            }
            else
            {
                writer.WriteLine($"public static {PartialType.QualifiedName} From{GenericType.Name}({GenericType.QualifiedName} value)");
            }
            writer.WriteLine("{");
            writer.Indent++;

            // TODO: Do mapping
            if (IsInto)
            {
                writer.WriteLine($"return new {GenericType.QualifiedName}");
            }
            else
            {
                writer.WriteLine($"return new {PartialType.QualifiedName}");
            }
            writer.WriteLine("{");
            writer.Indent++;

            foreach (var member in Members)
            {
                if (IsInto)
                {
                    writer.WriteLine($"{member} = {member},");
                }
                else
                {
                    writer.WriteLine($"{member} = value.{member},");
                }
            }

            // Close object creation
            writer.Indent--;
            writer.WriteLine("};");

            // Close method
            writer.Indent--;
            writer.WriteLine("}");

            // Close type
            writer.Indent--;
            writer.WriteLine("}");

            for (int i = 0; i < PartialType.Namespaces.Count; i++)
            {
                writer.Indent--;
                if (i == PartialType.Namespaces.Count - 1)
                {
                    writer.Write("}");
                }
                else
                {
                    writer.WriteLine("}");
                }
            }
        }
    }
}